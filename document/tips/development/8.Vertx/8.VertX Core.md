## Vert.x开发笔记【`Java`版】

`3.0`的模块支持清单：

* <font style="color:blue">**`Core`**</font>
* `Web`
* `Data access`
	* `MongoDB Client`
	* `JDBC Client`
	* `SQL common`
	* `Redis client`
* `Integration`
	* `Main Client`
	* `JCA Adaptor`
* `Authentication & Authorisation`
	* `Auth Common`
	* `JDBC Auth`
	* `JWT Auth`
	* `Shiro Auth`
* `Reactive`
	* `Vert.X Rx`
	* `Reactive streams`
* `Metrics`
* `Testing`
* `Clustering`
	* `Hazelcast`
* `Services`
	* `Service Factories`
	* `Service Proxies`
	* `Maven Service Factory`
	* `HTTP Service Factory`
* `Cloud and Docker`
	* `Vert.X OpenShift Cartridge`
	* `Vert.X OpenShift Using DIY Cartridge`
	* `Vert.X Docker Images`
* `Advanced`
	* `Codegen`
	* `Docgen`
	* `Codetrans`
	* `Distro`
	* `Web-Site`
<hr/>

### Vert.X Core【`Manual`】

### 1.功能表

* 书写`TCP`客户端和服务端
* 书写支持`WebSockets`的HTTP客户端和服务端
* `Event Bus`
* 数据共享——本地哈希表和集群分布式哈希表共享
* 预测以及延迟行为【`Periodic/Delayed`】
* `Verticle`的发布以及卸载【`Deploying/Undeploying`】
* 基于`Socket`的数据包
* `DNS`客户端
* 访问文件系统`File System`
* 高可用性：`High availability`
* 集群支持：`Cluster`

<hr/>

### 2.`Vert.X`对象

嵌入一个`Vertx`对象，并且创建一个`Vertx`的实例【`Instance`】：

	Vertx vertx = Vertx.vertx();
_NOTE：大部分应用仅仅需要一个`Vert.x`实例，但是如果有必要可以创建多个`Vert.x`实例，比如需要共享`Event Bus`以及使用不同的客户端和服务端组。_

为嵌入的`Vertx`提供配置选项的方式：

	Vertx vertx = Vertx.vertx(new VertxOptions().setWorkerPoolSize(40));
`VertxOptions`对象包含了各种`Vertx`需要的配置项，例如集群、高可用、池空间等。

### 3.`Fluent`的API

`Vertx`支持两种方式的API调用

**`Fluent`模式**

	request.response().putHeader("Content-Type", "text/plain").write("some text").end();
**`Non-Fluent`模式**

	HttpServerResponse response = request.response();
	response.putHeader("Content-Type", "text/plain");
	response.write("some text");
	response.end();

### 4.异步调用

`Vert.X`的API是大型事件驱动API【`Event Driven`】，它会通过发送事件的方式主动调用程序，而不是等待请求，事件如：

* 启用计时器【`Timer`】
* 通过`Socket`接受数据
* 直接从磁盘读取数据
* 异常发生
* 一个`HTTP`服务器接受请求

计时器例子

	vertx.setPeriodic(1000, id -> {
		// This handler will get called every second
		System.out.println("timer fired!");
	});
接受`HTTP`请求例子

	server.requestHandler(request -> {
		// This handler will be called every time an HTTP request is received at the server
		request.response().end("hello world!");
	});
<font style="color:red">核心概念：VertX的调用都是异步调用【`Asynchronously`】</font>

### 5.`Reactor`模式

`VertX`在调用程序时使用了名为`Event Loop`的线程，因为是基于非阻塞的`Reactor`设计模式【`Node.js`的实现模式】，所以在调用的时候针对同步方式【`Block Calling`】需要斟酌，同步的行为包括：

* 从`Socket`读取数据
* 写入数据到磁盘
* 发送请求以及等待相应
* 其他情况

标准的`Reactor`实现方式及基于单个事件循坏【`Single Event Loop`】，但是单个事件循坏导致的问题是在同一个时间中单个线程仅仅只能运行在单个核里，而`VertX`在这个模式中进行了提炼，每一个`Vert.X`的实例都维护了许多事件循坏队列【`Several Event Loop`】，默认情况下会根据机器的CPU的核数量来实现`Reactor`，这种模式称为：多路`Rector`模式【`Multi-Reactor Pattern`】。

### <font style="color:red">黄金法则：`Don't Block the Event Loop`</font>

因为`VertX`的API都是非阻塞异步模式，如果有需要实现阻塞同步调用的时候需要使用`VertX`提供的方式，而不是手动去实现，这个规则很重要，如果不遵循会引起系统的卡死，手动实现包括：

* `Thread.sleep()`
* 写一个锁`Lock`
* 写一个`Mutex`或者`Monitor`【一个同步块——`Synchorinzed`】
* 写一个访问时间很长的数据库访问操作并且等待结果
* 在一个有效时间内执行很复杂的运算
* 编写一个比较大的循环【`Loop`】

**significant amount of time**：整个事件循环队列执行的时间总和，调试`VertX`程序时可通过`VertxOptions`打开警告信息，则出现`Block`的时候可以看到下边类型日志：

	Thread vertx-eventloop-thread-3 has been blocked for 20458 ms

### 6.`Blocking Code`

阻塞同步方式的代码在某些情况下是不可避免的，如果需要实现`VertX`中的`Blocking Code`有两种方式：

**使用内联方法`executeBlocking`**

	vertx.executeBlocking(future -> {
		// Call some blocking API that takes a significant amount of time to return
		String result = someAPI.blockingMethod("hello");
		future.complete(result);
	}, res -> {
		System.out.println("The result is: " + res.result());
	});
默认情况下`Block`部分的代码会在`Context`或`Verticle`实例中依次执行，如果不关心这些代码的执行顺序则可以将`ordered`参数设置成`false`。

**使用`Worker Verticle`**

更简单的一种方式是使用`Worker`类型的`Verticle`来调用`Blocking Code`，这个实例通常会在一个`Worker`线程池中的某个线程内执行。

### 7.书写`Verticle`

书写`Verticle`通常有两种方式：

* `Verticle`类必须实现接口`Verticle`；
* `VertX`中还提供了抽象类`AbstractVerticle`，也可以直接从这个类中继承过来；

下边是一个简单的`Verticle`的例子：

	public class MyVerticle extends AbstractVerticle {

		// Called when verticle is deployed
		public void start() {
		}

		// Optional - called when verticle is undeployed
		public void stop() {
		}
	}

* **start**：该方法会在`Deploy`这个`Verticle`的时候调用；
* **stop**：该方法会在`Undeploy`这个`Verticle`的时候调用；

实现异步模式的`start`和`stop`，`VertX`实例的发布和卸载可以实现一个异步的版本，而这种实现是不会破坏上边的黄金法则【`Golden Rule`】的。

异步版本的`start`方法

	public class MyVerticle extends AbstractVerticle {

		public void start(Future<Void> startFuture) {
			// Now deploy some other verticle:
			vertx.deployVerticle("com.foo.OtherVerticle", res -> {
				if (res.succeeded()) {
					startFuture.complete();
				} else {
					startFuture.fail();
				}
			});
		}
	}
异步版本的`stop`方法





