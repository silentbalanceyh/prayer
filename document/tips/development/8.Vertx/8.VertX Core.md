## Vert.x开发笔记【`Java`版】

`3.0`的模块支持清单：

* <font style="color:blue">**`Core`**</font>
* `Web`
* `Data access`
	* `MongoDB Client`
	* `JDBC Client`
	* `SQL common`
	* `Redis client`
* `Integration`
	* `Main Client`
	* `JCA Adaptor`
* `Authentication & Authorisation`
	* `Auth Common`
	* `JDBC Auth`
	* `JWT Auth`
	* `Shiro Auth`
* `Reactive`
	* `Vert.X Rx`
	* `Reactive streams`
* `Metrics`
* `Testing`
* `Clustering`
	* `Hazelcast`
* `Services`
	* `Service Factories`
	* `Service Proxies`
	* `Maven Service Factory`
	* `HTTP Service Factory`
* `Cloud and Docker`
	* `Vert.X OpenShift Cartridge`
	* `Vert.X OpenShift Using DIY Cartridge`
	* `Vert.X Docker Images`
* `Advanced`
	* `Codegen`
	* `Docgen`
	* `Codetrans`
	* `Distro`
	* `Web-Site`
<hr/>

### Vert.X Core【`Manual`】

### 1.功能表

* 书写`TCP`客户端和服务端
* 书写支持`WebSockets`的HTTP客户端和服务端
* `Event Bus`
* 数据共享——本地哈希表和集群分布式哈希表共享
* 预测以及延迟行为【`Periodic/Delayed`】
* `Verticle`的发布以及卸载【`Deploying/Undeploying`】
* 基于`Socket`的数据包
* `DNS`客户端
* 访问文件系统`File System`
* 高可用性：`High availability`
* 集群支持：`Cluster`

<hr/>

### 2.`Vert.X`对象

嵌入一个`Vertx`对象，并且创建一个`Vertx`的实例【`Instance`】：

	Vertx vertx = Vertx.vertx();
_NOTE：大部分应用仅仅需要一个`Vert.x`实例，但是如果有必要可以创建多个`Vert.x`实例，比如需要共享`Event Bus`以及使用不同的客户端和服务端组。_

为嵌入的`Vertx`提供配置选项的方式：

	Vertx vertx = Vertx.vertx(new VertxOptions().setWorkerPoolSize(40));
`VertxOptions`对象包含了各种`Vertx`需要的配置项，例如集群、高可用、池空间等。

<hr/>

### 3.`Fluent`的API

`Vertx`支持两种方式的API调用

**`Fluent`模式**

	request.response().putHeader("Content-Type", "text/plain").write("some text").end();
**`Non-Fluent`模式**

	HttpServerResponse response = request.response();
	response.putHeader("Content-Type", "text/plain");
	response.write("some text");
	response.end();

<hr/>

### 4.异步调用

`Vert.X`的API是大型事件驱动API【`Event Driven`】，它会通过发送事件的方式主动调用程序，而不是等待请求，事件如：

* 启用计时器【`Timer`】
* 通过`Socket`接受数据
* 直接从磁盘读取数据
* 异常发生
* 一个`HTTP`服务器接受请求

计时器例子

	vertx.setPeriodic(1000, id -> {
		// This handler will get called every second
		System.out.println("timer fired!");
	});
接受`HTTP`请求例子

	server.requestHandler(request -> {
		// This handler will be called every time an HTTP request is received at the server
		request.response().end("hello world!");
	});
<font style="color:red">核心概念：VertX的调用都是异步调用【`Asynchronously`】</font>

<hr/>

### 5.`Reactor`模式

`VertX`在调用程序时使用了名为`Event Loop`的线程，因为是基于非阻塞的`Reactor`设计模式【`Node.js`的实现模式】，所以在调用的时候针对同步方式【`Block Calling`】需要斟酌，同步的行为包括：

* 从`Socket`读取数据
* 写入数据到磁盘
* 发送请求以及等待相应
* 其他情况

标准的`Reactor`实现方式及基于单个事件循坏【`Single Event Loop`】，但是单个事件循坏导致的问题是在同一个时间中单个线程仅仅只能运行在单个核里，而`VertX`在这个模式中进行了提炼，每一个`Vert.X`的实例都维护了许多事件循坏队列【`Several Event Loop`】，默认情况下会根据机器的CPU的核数量来实现`Reactor`，这种模式称为：多路`Rector`模式【`Multi-Reactor Pattern`】。

### <font style="color:red">黄金法则：`Don't Block the Event Loop`</font>

因为`VertX`的API都是非阻塞异步模式，如果有需要实现阻塞同步调用的时候需要使用`VertX`提供的方式，而不是手动去实现，这个规则很重要，如果不遵循会引起系统的卡死，手动实现包括：

* `Thread.sleep()`
* 写一个锁`Lock`
* 写一个`Mutex`或者`Monitor`【一个同步块——`Synchorinzed`】
* 写一个访问时间很长的数据库访问操作并且等待结果
* 在一个有效时间内执行很复杂的运算
* 编写一个比较大的循环【`Loop`】

**significant amount of time**：整个事件循环队列执行的时间总和，调试`VertX`程序时可通过`VertxOptions`打开警告信息，则出现`Block`的时候可以看到下边类型日志：

	Thread vertx-eventloop-thread-3 has been blocked for 20458 ms

<hr/>

### 6.`Blocking Code`

阻塞同步方式的代码在某些情况下是不可避免的，如果需要实现`VertX`中的`Blocking Code`有两种方式：

**使用内联方法`executeBlocking`**

	vertx.executeBlocking(future -> {
		// Call some blocking API that takes a significant amount of time to return
		String result = someAPI.blockingMethod("hello");
		future.complete(result);
	}, res -> {
		System.out.println("The result is: " + res.result());
	});
默认情况下`Block`部分的代码会在`Context`或`Verticle`实例中依次执行，如果不关心这些代码的执行顺序则可以将`ordered`参数设置成`false`。

**使用`Worker Verticle`**

更简单的一种方式是使用`Worker`类型的`Verticle`来调用`Blocking Code`，这个实例通常会在一个`Worker`线程池中的某个线程内执行。

<hr/>

### 7.书写`Verticle`

书写`Verticle`通常有两种方式：

* `Verticle`类必须实现接口`Verticle`；
* `VertX`中还提供了抽象类`AbstractVerticle`，也可以直接从这个类中继承过来；

下边是一个简单的`Verticle`的例子：

	public class MyVerticle extends AbstractVerticle {

		// Called when verticle is deployed
		public void start() {
		}

		// Optional - called when verticle is undeployed
		public void stop() {
		}
	}

* **start**：该方法会在`Deploy`这个`Verticle`的时候调用；
* **stop**：该方法会在`Undeploy`这个`Verticle`的时候调用；

实现异步模式的`start`和`stop`，`VertX`实例的发布和卸载可以实现一个异步的版本，而这种实现是不会破坏上边的黄金法则【`Golden Rule`】的。

异步版本的`start`方法

	public class MyVerticle extends AbstractVerticle {

		public void start(Future<Void> startFuture) {
			// Now deploy some other verticle:
			vertx.deployVerticle("com.foo.OtherVerticle", res -> {
				if (res.succeeded()) {
					startFuture.complete();
				} else {
					startFuture.fail();
				}
			});
		}
	}
异步版本的`stop`方法

	public class MyVerticle extends AbstractVerticle {

		public void start() {
			// Do something
		}

		public void stop(Future<Void> startFuture) {
			obj.doSomethingThatTakesTime(res -> {
				if (res.succeeded()) {
					startFuture.complete();
				} else {
					startFuture.fail();
				}
			});
		}
	}

<font style="color:red">在针对`Verticle`执行发布和卸载【`Deploy && Undeploy`】的操作时，所有子`Verticle`不需要手动发布，在发布父`Verticle`时它对应的子`Verticle`也会同时执行发布和卸载的动作。</font>

<hr/>

### 8.`Verticle`类型
`VertX`中包含了三种不同的`Verticle`：

#### 8.1.`Standard Verticles`
标准的`Verticle`在它被创建过后调用`start`方法时会被赋予一个事件循环线程【`Event Loop Thread`】，当你从事件循环中调用`Core API`时，`VertX`会生成对应的`Handler`，而这个`Handler`会在同一个事件循环中被执行。

也就是说：`VertX`保证了你写的`VertX Instance`中的代码在同一个事件循环中执行。

<font style="color:blue">这种情况下，你可以讲你的所有应用代码按照单线程模式来书写，并且不需要去考虑多线程和水平扩展问题，也不需要考虑同步以及线程安全性问题，这种开发方式和传统意义中的开发方式是相同的。</font>

#### 8.2.`Worker Verticles`

`Worker Verticle`和`Standard Verticle`有点类似，但是其不同在于这种类型的`Verticle`并不是使用一个事件循环【`Event Loop`】，而是直接从`Vert.X`的工作线程池中使用一个线程来实现。这种类型的`Verticle`主要的设计目的是在于调用阻塞式代码，上边已经提到过了，如果需要实现阻塞方式的调用，除了内联方式【`Inline Blocking Code`】，就是直接使用`Worker Verticle`。

下边的代码可以将一个`Verticle`通过编程方式设置成`Worker Verticle`

	DeploymentOptions options = new DeploymentOptions().setWorker(true);
	vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options);

<font style="color:blue">`Worker Verticle`的实例不可以被超过一个线程的`Vert.X`并发访问，但是它可以被不同的线程执行很多次。</font>

#### 8.3.`Multi-threaded Worker Verticle`

这种方式的`Verticle`是`3.0`出现的新方式，他和普通的`Worker Verticle`差不多，唯一的区别是可以被线程并发访问。

<font style="color:blue">这种类型的`Verticle`属于高级功能，大部分应用都不会使用到，因为这种方式会让开发人员考虑多线程环境中的对象并发访问状态的同步，以及更多标准多线程应用需要考虑的问题。</font>

<hr/>

### 9.编程方式发布`Verticle`

你可以使用`deployVerticle`方法来发布一个写好的`Verticle`，这种情况下仅需要`Verticle`的名字或者直接传入一个`Verticle`实例<font style="color:red">【实例传入的方式仅`Java`语言可支持！】</font>即可。

	Verticle myVerticle = new MyVerticle();
	vertx.deployVerticle(myVerticle);

除了上边的发布方式，还可以直接将一个`Verticle`的名称传入给`VerticleFactory`类，让这个类来实例化一个`Verticle`，不同的`Factory`可以针对不同语言写的`Verticle`实现实例化的操作，也就是说使用`name`的方式可以发布任何语言写的`Verticle`，如：

	vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle");

	// Deploy a JavaScript verticle
	vertx.deployVerticle("verticles/myverticle.js");

	// Deploy a Ruby verticle verticle
	vertx.deployVerticle("verticles/my_verticle.rb");

如果使用`name`实现发布，还可以通过不同的命名方式，在不加任何前缀的时候，`VertX`会使用`Java`语言的`FQCN`【`Fully Qualified Class Name`】来实例化这个`Verticle`，而使用前缀的方式如下：

	js:foo.js // Use the JavaScript verticle factory
	groovy:com.mycompany.SomeGroovyCompiledVerticle // Use the Groovy verticle factory
	service:com.mycompany:myorderservice // Uses the service verticle factory
如果前缀匹配有问题，还会使用后缀匹配的默认规则，如：

	foo.js // Will also use the JavaScript verticle factory
	SomeScript.groovy // Will use the Groovy verticle factory
<hr/>

### 10.`Verticle`的定位
大部分`Verticle`的工厂类都是直接从`CLASSPATH`中读取，并且在`Vert.X`启动的时候注册的，如果有必要可以使用`registerVerticleFactory`和`unregisterVerticleFactory`的方式手动注册以及注销`Verticle`的工厂类。

_Deployment_

	vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", res -> {
		if (res.succeeded()) {
			System.out.println("Deployment id is: " + res.result());
		} else {
			System.out.println("Deployment failed!");
		}
	});

_Undeployment_

	vertx.undeploy(deploymentID, res -> {
		if (res.succeeded()) {
			System.out.println("Undeployed ok");
		} else {
			System.out.println("Undeploy failed!");
		}
	});

如果使用`Verticle`的名称来发布`VertX`的实例，可以在发布的时候指定`Verticle`运行的实例数量：

	DeploymentOptions options = new DeploymentOptions().setInstances(16);
	vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options);

<hr/>

### 11.配置传递

`VertX`使用的配置本身可直接用`JSON`格式的数据进行编程设置：

	JsonObject config = new JsonObject().put("name", "tim").put("directory", "/blah");
	DeploymentOptions options = new DeploymentOptions().setConfig(config);
	vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options);

这个配置一旦初始化好了过后，会存在于上下文环境对象`Context`中，而且可以使用`config()`方法直接获取引用，如：

	System.out.println("Configuration: " + config().getString("name"));
除了上边的配置读写以外，还可以使用下边方式获取环境信息【`Java`信息】：

	System.getProperty("prop");
	System.getenv("HOME");

<hr/>

### 12.`Verticle`的独立组

默认情况下，`Vert.X`拥有一个平坦的`CLASSPATH`【`Flat Classpath`】，当`Vert.X`发布`Verticle`的时候它会使用当前的类加载器，它并不会创建一个新的，这种情况是最简单并且最直接的方式。

除了上边的情况以外，`Vert.X`提供了一个独立分组机制，这种情况使得不同的应用会拥有不同的类加载器【`ClassLoader`】——比如你想要`Deploy`两个不同版本的`Verticle`的同一个`Vert.X`实例，则需要使用各自独立的`CLASSPATH`的分组才可以。

使用编程的方式`setIsolatedClasses`可设置其类路径信息

* 全类名：`com.mycompany.myproject.engine.MyClass`
* 所有包内的类集合：`com.mycompany.myproject.*`

和`JVM`的类加载一样，`Vert.X`可以使用`setExtraClasspath`方法实现扩展类加载器【`Extension ClassLoader`】。

	DeploymentOptions options = new DeploymentOptions().setIsolationGroup("mygroup");
	options.setIsolatedClasses(Arrays.asList("com.mycompany.myverticle.*","com.mycompany.somepkg.SomeClass", "org.somelibrary.*"));
	vertx.deployVerticle("com.mycompany.myverticle.VerticleClass", options);

<hr/>

### 13.简单命令

`Vert.X`可以发布成`HA`【`High Availability`】架构，当发布的一个`Vert.X`出现问题的时候，系统会自动重发布另外的一个`Vert.X`实例来实现`HA`的功能，使用命令如：

	vertx run my-verticle.js -ha
只是有一个限制是必须使用参数：`-cluster`。

新版的`Vert.X`取消了原来的`Mod`结构，可以直接使用`Maven`或`Gradle`方式生成对应的模块，除此之外也可以直接从命令行运行。

* 确认`Vert.X`已经安装好了，并且将`bin`目录添加到系统的`PATH`中了，`vertx`命令可直接从命令行使用；
* 配置了`JDK 8`的系统环境，保证`java`命令可用；

运行实例：

	# Run a JavaScript verticle
	vertx run my_verticle.js

	# Run a Ruby verticle
	vertx run a_n_other_verticle.rb

	# Run a Groovy script verticle, clustered
	vertx run FooVerticle.groovy -cluster

Java版本的可以实现实时编译，直接运行`Java`的源代码：

	vertx run SomeJavaSourceFile.java

关于`Vert.X`的退出：

* `Vert.X`实例运行的线程并不是守护线程【`Daemon Threads`】，所以它会阻止`JVM`本身的退出；
* 如果`Vert.X`嵌入在你的应用中，则你可以调用`close`方法退出`Vert.X`，这种情况更加正规，会将所有对应资源释放包括内部线程池，最后允许`JVM`退出；

<hr/>

### 14.`Context`对象
当`Vert.X`传递一个`event`事件给`handler`或者调用`Verticle`的`start`或`stop`方法时，它执行的时候都会关联一个`Context`上下文环境，通常一个上下文环境是一个事件循环上下文【`Event-Loop Context`】，而且它本身使用了一个特殊的事件循环线程。

获取方式：

	Context context = vertx.getOrCreateContext();
下边代码是测试获取代码：

	Context context = vertx.getOrCreateContext();
	if (context.isEventLoopContext()) {
		System.out.println("Context attached to Event Loop");
	} else if (context.isWorkerContext()) {
		System.out.println("Context attached to Worker Thread");
	} else if (context.isMultiThreadedWorkerContext()) {
		System.out.println("Context attached to Worker Thread - multi threaded worker");
	} else if (! Context.isOnVertxThread()) {
		System.out.println("Context not attached to a thread managed by vert.x");
	}

一旦获取到了一个`Context`过后，就可以异步运行这个`Context`了

	vertx.getOrCreateContext().runOnContext( (v) -> {
		System.out.println("This will be executed asynchronously in the same context");
	});

如果一个`Vert.X`中运行了多个`Handler`，并且它们之间需要共享数据的时候，则可以将共享数据存放在`Context`中实现共享：

	final Context context = vertx.getOrCreateContext();
	context.put("data", "hello");
	context.runOnContext((v) -> {
		String hello = context.get("data");
	});

<hr/>

### 15.执行“周期”和“延迟”行为【`Periodic & Delayed`】
`Vert.X`可支持执行“周期”和“延迟”行为，在`Standard Verticle`中仅仅需要让线程休眠就可以实现延迟行为，这样它就会阻塞`Event Loop`线程：<font style="color:red">【*：这个是破坏了“黄金法则”的】</font>

除开上边的方法以外，也可以设置`Timer`来实现一次性或者周期性行为。

**`One-Shot Timers`**

	long timerID = vertx.setTimer(1000, id -> {
		System.out.println("And one second later this is printed");
	});

	System.out.println("First this is printed");

**`Periodic Timers`**

	long timerID = vertx.setPeriodic(1000, id -> {
		System.out.println("And every second this is printed");
	});

	System.out.println("First this is printed");

<font style="color:blue">取消一个`Timer`时可使用下边代码段，注意上边的调用中`id`就是返回的timer的ID号：</font>

	vertx.cancelTimer(timerID);

<hr/>

### 16.`Event Bus`事件总线

`Event Bus`是`Vert.X`中的神经系统【`Nervous System`】，每一个`Vert.X`实例有一个单独的`Event Bus`的实例，可直接通过方法`eventBus`来获得。它可以让相同或者不同的`Vert.X Instance`中的不同语言写的应用相互之间进行交互，不仅仅如此，它还可以让浏览器中的`JavaScript`和服务端进行直接的数据共享。

`Event Bus`实际上可以在多节点、多浏览器之间实现点对点的通讯，而且它支持下边三种模式：

* `Publish/Subscribe`
* `Point to Point`
* `Request-Response`

而它对应的API相对比较简单。

**相关理论【`Theory`】术语**

* **Addressing**<br/>
地址是`Event Bus`中的一个虚拟概念，所有的`Message`都会发送到地址上，`Vert.X`中使用的地址格式就是字符串，任何字符串都是符合规则的；

* **Handlers**<br/>
`Message`消息会被`Handler`所接受，而所有的`Handler`都必须注册在一个地址上，不同的`Handler`可以注册在不同的地址上，而相同的`Handler`也可以注册在不同的地址上；

* **Publish / Subscribe Messaging**<br/>
`EventBus`事件总线可支持发布消息的功能，这些消息会发布在一个地址上，发布消息会将消息通知发送给所有注册过的`Handler`上，这种模式类似于`Publish/Subscribe`消息模式；

* **Point to Point/Request-Response Messaging**<br/>
`EventBus`还支持`P2P`的点对点消息模式，消息会发送给地址，`Vert.X`则会使用路由功能将请求路由给某一个注册好的`Handler`中，如果这里注册的`handler`有很多，则其中一个会被筛选出来接收这个消息，它使用了并不严格的轮询模式。<br/>
<font style="color:blue">而下边的方式则是`Request-Response`消息模式：</font>
	* 如果一条消息被接受者接收，并且被对应的`Handler`处理，则接受者可以选择回复这条消息，这种情况下会调用`Reply Handler`来完成；
	* 如果这条消息响应给发送者，同样也可以被再次响应，这样的方式可实现双向通讯；
* **Best-effort Delivery**<br/>
`Vert.X`一般情况下会尽可能保证消息不会出现丢失的情况，这种机制称为`Best-Effort`，但是如果`EventBus`中出现了大面积错误信息，则也可能出现消息丢失的情况，如果你的应用是不允许信息丢失的，那么则要在代码中考虑好如何书写以及确保才可以，以及对应的`Recovery`机制；

* **Type of Messages**<br/>
`OOB`的`Vert.X`允许这几种类型在`EventBus`中传播：`Primitive/Simple，String，Buffers`，而在`Vert.X`另外一种很方便的类型就是使用`JSON`，而且它原生支持了`JSON`格式的数据类型，`JSON`则在`Vert.X`中更加通用，而`Vert.X`中的`Handler`也可以调用序列化或者反序列化系统来实现数据到对象的转换过程。

<hr/>

### 17.`Event Bus`的API

