## Vert.x开发笔记【`Java`版】

`3.0`的模块支持清单：

* `Core`
* <font style="color:blue">**`Web`**</font>
* `Data access`
	* `MongoDB Client`
	* `JDBC Client`
	* `SQL common`
	* `Redis client`
* `Integration`
	* `Main Client`
	* `JCA Adaptor`
* `Authentication & Authorisation`
	* `Auth Common`
	* `JDBC Auth`
	* `JWT Auth`
	* `Shiro Auth`
* `Reactive`
	* `Vert.X Rx`
	* `Reactive streams`
* `Metrics`
* `Testing`
* `Clustering`
	* `Hazelcast`
* `Services`
	* `Service Factories`
	* `Service Proxies`
	* `Maven Service Factory`
	* `HTTP Service Factory`
* `Cloud and Docker`
	* `Vert.X OpenShift Cartridge`
	* `Vert.X OpenShift Using DIY Cartridge`
	* `Vert.X Docker Images`
* `Advanced`
	* `Codegen`
	* `Docgen`
	* `Codetrans`
	* `Distro`
	* `Web-Site`
<hr/>

### Vert.X Web【`Manual`】

`Vert.X Web`项目是一个用来构造阻塞式`Web`应用程序的工具集。

`Vert.X Web`是建立在`Vert.X Core`基础之上的工具集，他提供了更加丰富的集合用于构造实时`Web`应用，它的开发者就是`Node.js`中的`Express`项目的主要负责人，而`Vert.X`的核心架构和`Node.js`几乎同源，所以`Vert.X Web`可以构建下边几种不同的应用：

* 基础的`Server-Side`的`Web`应用程序；
* 基于`Restful`的`Web Service`应用程序；
* `Real Time`使用服务端实时进行消息`Push`的`Web`应用程序；

`Vert.X Web`的核心功能包括：

* Routing (based on method, path, etc)
* Regular expression pattern matching for paths
* Extraction of parameters from paths
* Content negotiation
* Request body handling
* Body size limits
* Cookie parsing and handling
* Multipart forms
* Multipart file uploads
* Sub routers
* Session support - both local (for sticky sessions) and clustered (for non sticky)
* CORS (Cross Origin Resource Sharing) support
* Error page handler
* Basic Authentication
* Redirect based authentication
* Authorisation handlers
* JWT based authorization
* User/role/permission authorisation
* Favicon handling
* Template support for server side rendering, including support for the following template engines out of the box:
	* Handlebars
	* Jade
	* MVEL
	* Thymeleaf
* Response time handler
* Static file serving, including caching logic and directory listing.
* Request timeout support
* SockJS support
* Event-bus bridge

### 1.Re-cap on Vert.x core HTTP servers

下边是一个最简单的`HTTP Server`的例子【`Vert.X-Core`版】：

		HttpServer server = vertx.createHttpServer();
		server.requestHandler(request -> {
			// This handler gets called for each request that arrives on the server
			HttpServerResponse response = request.response();
			response.putHeader("content-type", "text/plain");
			// Write to the response and end it
			response.end("Hello World!");
		});
		server.listen(8080);
<font style="color:blue">上边的代码创建一个`HTTP Server`实例，其中还包含了`HTTP handler`的相关设置处理以及相应头的内容设置，最后会返回`Hello World`的字符串。</font>

<hr/>

### 2.Basic Vert.x-Web Concepts

`Vert.X`中提供了`Router`，这个类是`Vert.x-Web`中的核心概念，它是一个对象用来管理多个`Routes`实现请求路径的路由功能，一个`Router`可以接受一个`HTTP`请求，并且找到和路由请求匹配的处理`Route`，然后将这个请求路由转发到`Route`中。

`Route`可以拥有`handler`和它自身关联，然后接受这个请求，在这个请求接受过后就可以自己书写相关逻辑代码了。

示例如下【`Vert.X-Web`版】：

		HttpServer server = vertx.createHttpServer();
		Router router = Router.router(vertx);
		router.route().handler(routingContext -> {
			// This handler will be called for every request
			HttpServerResponse response = routingContext.response();
			response.putHeader("content-type", "text/plain");
			// Write to the response and end it
			response.end("Hello World from Vert.x-Web!");
		});
		server.requestHandler(router::accept).listen(8080);
上边的代码和最初的代码功能是差不多的，但实现则是使用的`Vert.X-Web`的方式，上边的例子所有的路由功能都会触发，因为并没有设置路由路径，只有一个独立的`routingContext`的`Handler`用于处理所有请求。

传入`Handler`的一个`object`是一个`RoutingContext`类的对象，它包含了标准的`Vert.X`中`HttpServerRequest`和`HttpServerResponse`对象，这种方式可保证实现`Web`应用更加简单，针对每一个请求而言，它会拥有一个唯一的`routing context instance`；一旦设置好了`Handler`过后，我们则可以设置所有的`request handler`将所有请求传入到`accept`的方法中。

<font style="color:red">上边是一个最简单的`Web`的实现。</font>

<hr/>

### 3.Handling requests and calling the next handler

当`Vert-X-Web`决定路由一个请求到匹配的`Route`时，它将会调用`route`的`handler`并且传入一个`RoutingContext`的实例，处理完这个请求过后，如果这个`handler`中的请求并没有处理完毕，可直接调用`next`方法将请求传入另外的一个`handler`继续处理；

		Route route1 = router.route("/some/path/").handler(routingContext -> {
			HttpServerResponse response = routingContext.response();
			// enable chunked responses because we will be adding data as
			// we execute over other handlers. This is only required once and
			// only if several handlers do output.
			response.setChunked(true);
			response.write("route1\n");
			// Call the next matching route after a 5 second delay
			routingContext.vertx().setTimer(5000, tid -> routingContext.next());
		});

		Route route2 = router.route("/some/path/").handler(routingContext -> {
			HttpServerResponse response = routingContext.response();
			response.write("route2\n");
			// Call the next matching route after a 5 second delay
			routingContext.vertx().setTimer(5000, tid ->  routingContext.next());
		});

		Route route3 = router.route("/some/path/").handler(routingContext -> {
			HttpServerResponse response = routingContext.response();
			response.write("route3");
			// Now end the response
			routingContext.response().end();
		});
上边的例子中的执行流程如下：

1. `route1`先执行并且写入数据到`response`对象中；
2. 等待5秒过后`route2`执行；
3. 再等待5秒过后`route3`执行；

<hr/>

### 4.Using blocking handlers

在某些情况下，你需要阻塞`event loop`一段时间并且执行同步的`handler`信息，这样的情况则不可以使用`Normal Handler`来处理，这种情况则需要使用`Vert.X`中的阻塞式`Handler`——`blocking handler`。

`blocking handler`和`normal handler`有点类似，但是它是`Vert.X`从`Worker Pool`中提取的一个线程处理，而并没有使用`Event Loop`，其示例如下：

		router.route().blockingHandler(routingContext -> {
			// Do something that might take some time synchronously
			service.doSomethingThatBlocks();
			// Now call the next handler
			routingContext.next();
		});
默认情况下，任何`blocking handlers`都会在同一个`Context`中按照顺序【`Ordered`】执行，也就是说前边一个完成过后下边一个才会执行，如果你不关心顺序问题则需要把`blockingHandler`的属性`ordered`设置为`false`。

<hr/>

### 5.Routing by exact path

一个`route`可以设置用来匹配请求路径【`request URI`】，如果提供的路径一旦匹配成功，那么发送到这个路径的任何请求都会被处理。下边的例子中，`handler`的规则如下：

* `/some/path/`的请求会被处理；
* `/some/path`和`/some/path//`的请求都不会被处理；

看看示例的内容：

		Route route = router.route().path("/some/path/");
		route.handler(routingContext -> {
			// This handler will be called for the following request paths:
			// `/some/path`
			// `/some/path/`
			// `/some/path//`
			//
			// but not:
			// `/some/path/subdir`
		});

<hr/>

### 6.Routing by paths that begin with something

除了上边的精确匹配以外，`request URL`中还可以使用正则表达式，最简单的通配符就是使用`*`进行匹配，比如下边的例子，其规则如：以`/some/path/`开头的路径都可以匹配。

		Route route = router.route().path("/some/path/*");
		route.handler(routingContext -> {
			// This handler will be called for the following request paths:
			// `/some/path`
			// `/some/path/`
			// `/some/path//`
			//
			// but not:
			// `/some/path/subdir`
		});

如`/some/path/foo.html`，`/some/path/otherdir/blah.css`，下边的创建方式和上边的结果是一致的：

		Route route = router.route("/some/path/*");
		route.handler(routingContext -> {
			// This handler will be called same as previous example
		});

<hr/>

### 7.Capturing path parameters

除了上边的两种匹配方式以外，还可以针对特殊的参数使用占位符的方式来设置`request`请求的参数信息——`params`。

		Route route = router.route(HttpMethod.POST, "/catalogue/products/:productype/:productid/");
		route.handler(routingContext -> {
			String productType = routingContext.request().getParam("producttype");
			String productID = routingContext.request().getParam("productid");
			// Do something with them...
		});
占位符使用`:`开始，后边跟上参数名称，参数名包含英文字母、数字、下划线三种字符任意组合格式。回到上边的例子，如果请求路径为：`/catalogue/products/tools/drill123/`

* producttype = tools
* productid = drill123

<hr/>

### 8.Routing with regular expressions

下边的例子是使用正则表达式的方式进行路径匹配：

		Route route = router.route().pathRegex(".*foo");
		route.handler(routingContext -> {
			// This handler will be called for:
			// /some/path/foo
			// /foo
			// /foo/bar/wibble/foo
			// /foo/bar
			// But not:
			// /bar/wibble
		});
除了上边这种方式，下边的代码也是等价的：

		Route route = router.routeWithRegex(".*foo");
		route.handler(routingContext -> {
			// This handler will be called same as previous example
		});
<hr/>

### 9.Capturing path parameters with regular expressions

使用正则表达式进行路径匹配的时候，同样可以抓取参数，如下边例子：

		Route route = router.routeWithRegex(".*foo");
		// This regular expression matches paths that start with something like:
		// "/foo/bar" - where the "foo" is captured into param0 and the "bar" is captured into
		// param1
		route.pathRegex("\\/([^\\/]+)\\/([^\\/]+)").handler(routingContext -> {
			String productType = routingContext.request().getParam("param0");
			String productID = routingContext.request().getParam("param1");
			// Do something with them...
		});
在上边的例子中，如果一个请求是`/tools/drill123/`，则

* productType = tools ( param0 )
* productID = drill123 ( param1 )

<hr/>

### 10.Routing by HTTP method

默认情况下，`Route`匹配的是所有的`HTTP method`，如果想要针对特殊的`HTTP`方法进行匹配，则需要使用`method`方法来实现路由：

		Route route = router.route().method(HttpMethod.POST);
		route.handler(routingContext -> {
			// This handler will be called for any POST request
		});
除了上边的方式以外，还可以使用下边的代码创建特定`method`中的请求

		Route route = router.route(HttpMethod.POST, "/some/path/");
		route.handler(routingContext -> {
			// This handler will be called for any POST request to a URI path starting with /some/path/
		});
如果仅仅针对某种特定的方法实现路由功能，还可以使用下边的代码【`get, post, put`】：

		router.get().handler(routingContext -> {
			// Will be called for any GET request
		});
		router.get("/some/path/").handler(routingContext -> {
			// Will be called for any GET request to a path
			// starting with /some/path
		});
		router.getWithRegex(".*foo").handler(routingContext -> {
			// Will be called for any GET request to a path
			// ending with `foo`
		});
如果想要当前的`Route`能够匹配更多的`HTTP Method`，则可以使用下边的代码链结构：

		Route route = router.route().method(HttpMethod.POST).method(HttpMethod.PUT);
		route.handler(routingContext -> {
			// This handler will be called for any POST or PUT request
		});

<hr/>

### 11.Route Order

默认情况下，`Route`会按照`Router`匹配过程中的顺序来决定`Route`的顺序；当一个请求被接收过后，`Router`将会一个一个检查`route`并且检查是否匹配`Request URI`，如果匹配则`Route`中的`Handler`会直接被选择调用。

如果这个`Handler`在顺序调用中调用了`next()`方法则会调用下一个可匹配的`Handler`继续处理请求，这种流程称为“子顺序”流程：

		Route route1 = router.route("/some/path/").handler(routingContext -> {
			HttpServerResponse response = routingContext.response();
			// enable chunked responses because we will be adding data as
			// we execute over other handlers. This is only required once and
			// only if several handlers do output.
			response.setChunked(true);
			response.write("route1\n");
			// Now call the next matching route
			routingContext.next();
		});

		Route route2 = router.route("/some/path/").handler(routingContext -> {
			HttpServerResponse response = routingContext.response();
			response.write("route2\n");
			// Now call the next matching route
			routingContext.next();
		});

		Route route3 = router.route("/some/path/").handler(routingContext -> {
			HttpServerResponse response = routingContext.response();
			response.write("route3");
			// Now end the response
			routingContext.response().end();
		});
上边的例子中`response`将会包含：

	route1
	route2
	route3
也就是说上边的`route`调用过后其请求顺序从`/some/path`的匹配开始，如果要重写默认的`routes`顺序，则可以使用`order`方法，提供一个整数值，这个数值按照从小到大的方式来排列，也就是说`order`为`0`的`route`先执行，然后`order`为`1`的`route`再执行；提供了这个值过后其默认的顺序就会被打乱，而且这个`order`值可以是负数，只是按照从小到大进行排序。

看看下边的例子：

		Route route1 = router.route("/some/path/").handler(routingContext -> {
			HttpServerResponse response = routingContext.response();
			response.write("route1\n");
			// Now call the next matching route
			routingContext.next();
		});

		Route route2 = router.route("/some/path/").handler(routingContext -> {
			HttpServerResponse response = routingContext.response();
			// enable chunked responses because we will be adding data as
			// we execute over other handlers. This is only required once and
			// only if several handlers do output.
			response.setChunked(true);
			response.write("route2\n");
			// Now call the next matching route
			routingContext.next();
		});

		Route route3 = router.route("/some/path/").handler(routingContext -> {
			HttpServerResponse response = routingContext.response();
			response.write("route3");
			// Now end the response
			routingContext.response().end();
		});

		// Change the order of route2 so it runs before route1
		route2.order(-1);
上边代码执行过后如下：

	route2
	route1
	route3
如果两个`route`的`order`值相等，则按照添加的顺序来执行，不仅仅如此，`route`中提供了一个`last`方法用于执行最后一个`handler`。

<hr/>

### 12.Routing based on MIME type of request

bnn



